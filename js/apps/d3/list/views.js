// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['apps/d3/list/templates', 'views/_base', 'd3'], function(Templates, AppView) {
    var DataVisLayout, _item, _ref, _ref1, _ref2;
    return {
      DataVis1: _item = (function(_super) {
        __extends(_item, _super);

        function _item() {
          this.onRender = __bind(this.onRender, this);
          _ref = _item.__super__.constructor.apply(this, arguments);
          return _ref;
        }

        _item.prototype.template = _.template(Templates.datavis);

        _item.prototype.className = "well";

        _item.prototype.onRender = function() {
          var collide, color, force, height, nodes, root, svg, width;
          width = 400;
          height = 600;
          nodes = d3.range(50).map(function() {
            return {
              radius: Math.random() * 12 + 4
            };
          });
          root = nodes[0];
          color = d3.scale.category10();
          root.radius = 0;
          root.fixed = true;
          force = d3.layout.force().gravity(0.20).charge(function(d, i) {
            if (i) {
              return 0;
            } else {
              return -2000;
            }
          }).nodes(nodes).size([width, height]);
          force.start();
          svg = d3.select(this.el).append("svg:svg").attr("width", width).attr("height", height);
          svg.selectAll("circle").data(nodes.slice(1)).enter().append("circle").attr("r", function(d) {
            return d.radius - 2;
          }).style("fill", function(d, i) {
            return color(i % 5);
          });
          force.on("tick", function(e) {
            var i, n, q;
            q = d3.geom.quadtree(nodes);
            i = 0;
            n = nodes.length;
            while (++i < n) {
              q.visit(collide(nodes[i]));
            }
            return svg.selectAll("circle").attr("cx", function(d) {
              return d.x;
            }).attr("cy", function(d) {
              return d.y;
            });
          });
          svg.on("mousemove", function() {
            var p1;
            p1 = d3.mouse(this);
            root.px = p1[0];
            root.py = p1[1];
            return force.resume();
          });
          return collide = function(node) {
            var nx1, nx2, ny1, ny2, r;
            r = node.radius + 16;
            nx1 = node.x - r;
            nx2 = node.x + r;
            ny1 = node.y - r;
            ny2 = node.y + r;
            return function(quad, x1, y1, x2, y2) {
              var l, x, y;
              if (quad.point && (quad.point !== node)) {
                x = node.x - quad.point.x;
                y = node.y - quad.point.y;
                l = Math.sqrt(x * x + y * y);
                r = node.radius + quad.point.radius;
                if (l < r) {
                  l = (l - r) / l * .5;
                  node.x -= x *= l;
                  node.y -= y *= l;
                  quad.point.x += x;
                  quad.point.y += y;
                }
              }
              return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            };
          };
        };

        return _item;

      })(AppView.ItemView),
      DataVis2: _item = (function(_super) {
        __extends(_item, _super);

        function _item() {
          this.onRender = __bind(this.onRender, this);
          _ref1 = _item.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        _item.prototype.template = _.template(Templates.datavis);

        _item.prototype.className = "well";

        _item.prototype.onRender = function() {
          var collide, color, force, height, nodes, root, svg, width;
          width = 400;
          height = 600;
          nodes = d3.range(100).map(function() {
            return {
              radius: Math.random() * 12 + 4
            };
          });
          root = nodes[0];
          color = d3.scale.category10();
          root.radius = 0;
          root.fixed = true;
          force = d3.layout.force().gravity(0.10).charge(function(d, i) {
            if (i) {
              return 0;
            } else {
              return -2000;
            }
          }).nodes(nodes).size([width, height]);
          force.start();
          svg = d3.select(this.el).append("svg:svg").attr("width", width).attr("height", height);
          svg.selectAll("circle").data(nodes.slice(1)).enter().append("circle").attr("r", function(d) {
            return d.radius - 2;
          }).style("fill", function(d, i) {
            return color(i % 5);
          });
          force.on("tick", function(e) {
            var i, n, q;
            q = d3.geom.quadtree(nodes);
            i = 0;
            n = nodes.length;
            while (++i < n) {
              q.visit(collide(nodes[i]));
            }
            return svg.selectAll("circle").attr("cx", function(d) {
              return d.x;
            }).attr("cy", function(d) {
              return d.y;
            });
          });
          svg.on("mousemove", function() {
            var p1;
            p1 = d3.mouse(this);
            root.px = p1[0];
            root.py = p1[1];
            return force.resume();
          });
          return collide = function(node) {
            var nx1, nx2, ny1, ny2, r;
            r = node.radius + 16;
            nx1 = node.x - r;
            nx2 = node.x + r;
            ny1 = node.y - r;
            ny2 = node.y + r;
            return function(quad, x1, y1, x2, y2) {
              var l, x, y;
              if (quad.point && (quad.point !== node)) {
                x = node.x - quad.point.x;
                y = node.y - quad.point.y;
                l = Math.sqrt(x * x + y * y);
                r = node.radius + quad.point.radius;
                if (l < r) {
                  l = (l - r) / l * .5;
                  node.x -= x *= l;
                  node.y -= y *= l;
                  quad.point.x += x;
                  quad.point.y += y;
                }
              }
              return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            };
          };
        };

        return _item;

      })(AppView.ItemView),
      Layout: DataVisLayout = (function(_super) {
        __extends(DataVisLayout, _super);

        function DataVisLayout() {
          _ref2 = DataVisLayout.__super__.constructor.apply(this, arguments);
          return _ref2;
        }

        DataVisLayout.prototype.template = _.template(Templates.layout);

        DataVisLayout.prototype.regions = {
          panelRegion: "#panel-region",
          dataVisRegion1: "#datavis-region1",
          dataVisRegion2: "#datavis-region2"
        };

        return DataVisLayout;

      })(AppView.Layout)
    };
  });

}).call(this);
